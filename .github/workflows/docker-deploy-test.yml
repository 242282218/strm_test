name: Full Stack CI

on:
  workflow_dispatch:
  push:
    branches-ignore:
      - main
  pull_request:
    branches:
      - main

jobs:
  frontend-quality:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          cache-dependency-path: web/package-lock.json

      - name: Install frontend dependencies
        working-directory: web
        run: npm ci

      - name: Frontend lint
        id: frontend_lint
        continue-on-error: true
        working-directory: web
        run: npm run lint

      - name: Frontend lint result
        if: steps.frontend_lint.outcome == 'failure'
        run: echo "Frontend lint failed (non-blocking in branch CI)."

      - name: Frontend type-check and build
        id: frontend_build
        continue-on-error: true
        working-directory: web
        run: npm run build

      - name: Frontend build result
        if: steps.frontend_build.outcome == 'failure'
        run: echo "Frontend type-check/build failed (non-blocking in branch CI)."

  backend-quality:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"
          cache: pip
          cache-dependency-path: requirements.txt

      - name: Install backend dependencies
        run: pip install -r requirements.txt

      - name: Prepare config for backend checks
        run: |
          if [ -f config.clawcloud.example.yaml ]; then
            cp config.clawcloud.example.yaml config.yaml
          else
            cp config.example.yaml config.yaml
          fi
          mkdir -p logs strm
          touch quark_strm.db

      - name: Backend syntax check
        run: python -m compileall app

      - name: Run backend tests (if present)
        run: |
          if find . -type f -name "test_*.py" | grep -q .; then
            pytest -q
          else
            echo "No backend test files found. Skipping pytest."
          fi

      - name: Backend import smoke check
        run: |
          python - <<'PY'
          from app.main import app
          print(app.title)
          print("routes", len(app.routes))
          PY

  docker-integration:
    needs:
      - frontend-quality
      - backend-quality
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare runtime files
        run: |
          if [ -f config.clawcloud.example.yaml ]; then
            cp config.clawcloud.example.yaml config.yaml
          else
            cp config.example.yaml config.yaml
          fi
          mkdir -p logs strm
          touch quark_strm.db

      - name: Build Dockerfile directly
        run: docker build -t quark-strm-ci .

      - name: Validate compose file
        run: docker compose config -q

      - name: Build docker image
        run: docker compose build

      - name: Start services
        run: docker compose up -d

      - name: Wait for health endpoint
        run: |
          for i in $(seq 1 45); do
            if curl -fsS "http://127.0.0.1:18000/health" > /tmp/health.json; then
              cat /tmp/health.json
              exit 0
            fi
            sleep 2
          done
          echo "Health check failed after waiting."
          docker compose ps
          docker compose logs --no-color
          exit 1

      - name: Smoke test root endpoint
        run: curl -fsS "http://127.0.0.1:18000/"

      - name: Capture runtime diagnostics
        if: always()
        run: |
          docker compose ps > compose-ps.txt || true
          docker compose logs --no-color > compose-logs.txt || true

      - name: Upload docker diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quark-strm-docker-diagnostics
          path: |
            compose-ps.txt
            compose-logs.txt
            logs
          if-no-files-found: warn

      - name: Stop services
        if: always()
        run: docker compose down -v --remove-orphans || true

  publish-ghcr:
    if: ${{ github.event_name == 'push' && github.ref_name != 'main' }}
    needs:
      - docker-integration
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Prepare image metadata
        id: image_meta
        run: |
          BRANCH_TAG=$(echo "${GITHUB_REF_NAME}" | tr '[:upper:]' '[:lower:]' | sed 's#[^a-z0-9._-]#-#g')
          IMAGE_NAME="ghcr.io/${GITHUB_REPOSITORY,,}"
          echo "branch_tag=${BRANCH_TAG}" >> "$GITHUB_OUTPUT"
          echo "image_name=${IMAGE_NAME}" >> "$GITHUB_OUTPUT"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ steps.image_meta.outputs.image_name }}:branch-${{ steps.image_meta.outputs.branch_tag }}
            ${{ steps.image_meta.outputs.image_name }}:sha-${{ github.sha }}

      - name: Publish image pull URLs
        run: |
          echo "### GHCR Image" >> "$GITHUB_STEP_SUMMARY"
          echo "- docker pull ${{ steps.image_meta.outputs.image_name }}:branch-${{ steps.image_meta.outputs.branch_tag }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- docker pull ${{ steps.image_meta.outputs.image_name }}:sha-${{ github.sha }}" >> "$GITHUB_STEP_SUMMARY"

  deploy-test-machine:
    if: ${{ github.event_name == 'push' && github.ref_name != 'main' }}
    needs:
      - publish-ghcr
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      TEST_HOST: 149.88.74.147
      TEST_SSH_USER: ${{ secrets.TEST_SSH_USER }}
      TEST_SSH_PRIVATE_KEY: ${{ secrets.TEST_SSH_PRIVATE_KEY }}
      TEST_SSH_PASSWORD: ${{ secrets.TEST_SSH_PASSWORD }}
      TEST_GHCR_USERNAME: ${{ secrets.TEST_GHCR_USERNAME }}
      TEST_GHCR_TOKEN: ${{ secrets.TEST_GHCR_TOKEN }}

    steps:
      - name: Validate deploy credentials
        run: |
          echo "skip_deploy=false" >> "$GITHUB_ENV"
          if [ -z "${TEST_SSH_USER:-}" ]; then
            echo "skip_deploy=true" >> "$GITHUB_ENV"
            echo "TEST_SSH_USER is missing, skip remote deploy."
            exit 0
          fi
          if [ -z "${TEST_SSH_PRIVATE_KEY:-}" ] && [ -z "${TEST_SSH_PASSWORD:-}" ]; then
            echo "skip_deploy=true" >> "$GITHUB_ENV"
            echo "Neither TEST_SSH_PRIVATE_KEY nor TEST_SSH_PASSWORD is set, skip remote deploy."
            exit 0
          fi

      - name: Prepare image metadata
        if: env.skip_deploy != 'true'
        id: image_meta
        run: |
          BRANCH_TAG=$(echo "${GITHUB_REF_NAME}" | tr '[:upper:]' '[:lower:]' | sed 's#[^a-z0-9._-]#-#g')
          IMAGE_NAME="ghcr.io/${GITHUB_REPOSITORY,,}"
          IMAGE_REF="${IMAGE_NAME}:branch-${BRANCH_TAG}"
          echo "image_ref=${IMAGE_REF}" >> "$GITHUB_OUTPUT"

      - name: Prepare SSH auth
        if: env.skip_deploy != 'true'
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "$TEST_HOST" >> ~/.ssh/known_hosts

          if [ -n "${TEST_SSH_PRIVATE_KEY:-}" ]; then
            printf '%s\n' "${TEST_SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
            chmod 600 ~/.ssh/id_ed25519
            echo "auth_method=key" >> "$GITHUB_ENV"
          else
            sudo apt-get update
            sudo apt-get install -y sshpass
            echo "auth_method=password" >> "$GITHUB_ENV"
          fi

      - name: Create deploy compose file
        if: env.skip_deploy != 'true'
        run: |
          cat > deploy-compose.yml <<EOF
          name: strm_test
          services:
            app:
              image: ${{ steps.image_meta.outputs.image_ref }}
              container_name: strm_test
              restart: unless-stopped
              ports:
                - "18000:18000"
              environment:
                PORT: "18000"
                WEB_CONCURRENCY: "1"
                CONFIG_PATH: /data/config.yaml
              volumes:
                - /root/strm_test/data:/data
          EOF

      - name: Upload compose to test machine
        if: env.skip_deploy != 'true'
        run: |
          if [ "$auth_method" = "key" ]; then
            ssh -i ~/.ssh/id_ed25519 "${TEST_SSH_USER}@$TEST_HOST" "mkdir -p /root/strm_test"
            scp -i ~/.ssh/id_ed25519 deploy-compose.yml \
              "${TEST_SSH_USER}@$TEST_HOST:/root/strm_test/docker-compose.yml"
          else
            sshpass -p "${TEST_SSH_PASSWORD}" ssh "${TEST_SSH_USER}@$TEST_HOST" "mkdir -p /root/strm_test"
            sshpass -p "${TEST_SSH_PASSWORD}" scp deploy-compose.yml \
              "${TEST_SSH_USER}@$TEST_HOST:/root/strm_test/docker-compose.yml"
          fi

      - name: Deploy on test machine
        if: env.skip_deploy != 'true'
        run: |
          cat > remote-deploy.sh <<'EOF'
          set -euo pipefail

          SUDO=""
          if [ "$(id -u)" -ne 0 ]; then
            SUDO="sudo"
          fi

          ensure_docker() {
            if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
              return 0
            fi

            if [ -f /etc/os-release ]; then
              . /etc/os-release
            else
              echo "Unsupported OS: /etc/os-release not found"
              exit 1
            fi

            case "${ID:-}" in
              ubuntu|debian)
                $SUDO apt-get update
                $SUDO apt-get install -y ca-certificates curl gnupg lsb-release
                $SUDO install -m 0755 -d /etc/apt/keyrings
                curl -fsSL "https://download.docker.com/linux/${ID}/gpg" | $SUDO gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                $SUDO chmod a+r /etc/apt/keyrings/docker.gpg
                CODENAME="${VERSION_CODENAME:-}"
                if [ -z "$CODENAME" ]; then
                  CODENAME="$(lsb_release -cs)"
                fi
                echo \
                  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/${ID} ${CODENAME} stable" | \
                  $SUDO tee /etc/apt/sources.list.d/docker.list > /dev/null
                $SUDO apt-get update
                $SUDO apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                ;;
              centos|rhel|rocky|almalinux)
                if command -v dnf >/dev/null 2>&1; then
                  $SUDO dnf -y install dnf-plugins-core
                  $SUDO dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
                  $SUDO dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                else
                  $SUDO yum -y install yum-utils
                  $SUDO yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
                  $SUDO yum -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                fi
                ;;
              fedora)
                $SUDO dnf -y install dnf-plugins-core
                $SUDO dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo
                $SUDO dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                ;;
              *)
                echo "Unsupported Linux distro: ${ID:-unknown}"
                exit 1
                ;;
            esac

            $SUDO systemctl enable --now docker || true
          }

          ensure_docker

          DOCKER_BIN="docker"
          if [ -n "$SUDO" ]; then
            DOCKER_BIN="$SUDO docker"
          fi

          mkdir -p /root/strm_test/data
          cd /root/strm_test

          if [ -n "${GHCR_USERNAME:-}" ] && [ -n "${GHCR_TOKEN:-}" ]; then
            echo "$GHCR_TOKEN" | $DOCKER_BIN login ghcr.io -u "$GHCR_USERNAME" --password-stdin
          fi

          $DOCKER_BIN compose pull
          $DOCKER_BIN compose up -d --remove-orphans
          $DOCKER_BIN compose ps
          curl -fsS http://127.0.0.1:18000/health
          EOF

          if [ "$auth_method" = "key" ]; then
            ssh -i ~/.ssh/id_ed25519 "${TEST_SSH_USER}@$TEST_HOST" \
              "GHCR_USERNAME='${TEST_GHCR_USERNAME}' GHCR_TOKEN='${TEST_GHCR_TOKEN}' bash -s" < remote-deploy.sh
          else
            sshpass -p "${TEST_SSH_PASSWORD}" ssh "${TEST_SSH_USER}@$TEST_HOST" \
              "GHCR_USERNAME='${TEST_GHCR_USERNAME}' GHCR_TOKEN='${TEST_GHCR_TOKEN}' bash -s" < remote-deploy.sh
          fi

      - name: Publish deployment URL
        if: env.skip_deploy != 'true'
        run: |
          echo "### Test Deployment" >> "$GITHUB_STEP_SUMMARY"
          echo "- URL: http://$TEST_HOST:18000/" >> "$GITHUB_STEP_SUMMARY"
          echo "- Image: ${{ steps.image_meta.outputs.image_ref }}" >> "$GITHUB_STEP_SUMMARY"

      - name: Deployment skipped notice
        if: env.skip_deploy == 'true'
        run: |
          echo "### Test Deployment" >> "$GITHUB_STEP_SUMMARY"
          echo "- Skipped: missing TEST_SSH_USER or SSH auth secret." >> "$GITHUB_STEP_SUMMARY"
